//go:build ignore

#include "common.h"
#include <asm-generic/types.h>
#include <asm/bitsperlong.h>
// #include <byteswap.h>
// #include <arpa/inet.h>
#include "bpf_endian.h"
#include "bpf_helpers.h"

#include "bpf_tracing.h"
#include <linux/bpf.h>
#include <linux/types.h>
#include <stdbool.h>

// #include <errno.h>
// #include <gnu/stubs-32.h>
// #include <linux/in.h>
// #include <linux/types.h>
// #include <stdbool.h>

char __license[] SEC("license") = "Dual MIT/GPL";

struct bpf_map_def SEC("maps") pkt_count = {
	.type        = BPF_MAP_TYPE_ARRAY,
	.key_size    = sizeof(u32),
	.value_size  = sizeof(u64),
	.max_entries = 1,
};

// u32 nr_cpus = BPF_CORE_READ(NR_CPUS);

// struct bpf_spin_lock;
struct bpf_spin_lock {
	__u32 val;
};
struct vaccant_port {
	u32 port;
	u32 occupied;
	u32 dest_ip;
	u32 dest_port;
	struct bpf_spin_lock lock;
};

struct dest_info {
	u32 dest_ip;
	u32 dest_port;
};

struct bpf_map_def SEC("maps") port_mapping = {
	.type        = BPF_MAP_TYPE_HASH,
	.key_size    = sizeof(u32),
	.value_size  = sizeof(struct dest_info),
	.max_entries = 1,
};

// struct bpf_map_def SEC("maps") vaccant_ports = {
// 	.type       = BPF_MAP_TYPE_ARRAY,
// 	.key_size   = sizeof(u32),
// 	.value_size = sizeof(struct vaccant_port),
// 	// .value_size  = sizeof(u32),
// 	.max_entries = 50,
// };

// int fd;
// union bpf_attr attr = {
// 	.map_type    = BPF_MAP_TYPE_ARRAY, /* mandatory */
// 	.key_size    = sizeof(__u32),      /* mandatory */
// 	.value_size  = sizeof(__u32),      /* mandatory */
// 	.max_entries = 256,                /* mandatory */
// 	// .map_flags = BPF_F_MMAPABLE;
// 	.map_name = "vaccant_Queue",
// };

// int fd = bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
// int fd = 9;

// struct bpf_map_def SEC("maps") vaccant_Queue = {
// 	// __uint(type, BPF_MAP_TYPE_QUEUE);
// 	// __type(value, __u32);
// 	// __uint(max_entries, 10);
// 	.type = BPF_MAP_TYPE_QUEUE,
// 	// .type = BPF_MAP_TYPE_PERCPU_ARRAY,

// 	.key_size    = sizeof(u32),
// 	.value_size  = sizeof(u64),
// 	.max_entries = 50,
// };

// [5002 , ... , 5001]

u64 PID      = 631603;
u16 NEW_PORT = 5000; // Choose the desired port number
u32 NEW_IP   = 0;    // 192.168.1.23 in hexadecimal forma

// use this format for decalring map with bpf_spin_lock so, that btf is generated by using "-g" flag in the compilation cmd
struct {
	__uint(type, BPF_MAP_TYPE_ARRAY);
	__type(key, u32);
	__type(value, struct vaccant_port);
	__uint(max_entries, 50);
} vaccant_ports SEC(".maps");

SEC("cgroup_skb/egress")
int count_egress_packets(struct __sk_buff *skb) {
	u32 key      = 0;
	u64 init_val = 1;

	u64 *count = bpf_map_lookup_elem(&pkt_count, &key);
	if (!count) {
		bpf_map_update_elem(&pkt_count, &key, &init_val, BPF_ANY);
		return 1;
	}
	__sync_fetch_and_add(count, 1);

	return 1;
}

SEC("cgroup/connect4")
int k_connect4(struct bpf_sock_addr *ctx) {
	u64 id  = bpf_get_current_pid_tgid();
	u32 pid = id >> 32;
	bpf_printk("expected pid: %lu, and calling process pid: %lu", PID, pid);
	if (pid != PID) {
		return 1;
	}
	bpf_printk("connect4 called [PID:%lu]\n", pid);

	volatile u32 protocol = ctx->protocol;

	if (protocol != 6) {
		return 1;
	}

	// destination ip
	u16 dst_ip_u = (u16)ctx->user_ip4;
	u32 dst_ip   = (u32)bpf_ntohs(dst_ip_u);
	// destination port
	u16 dst_port_u = (u16)ctx->user_port;
	u16 dst_port   = bpf_ntohs(dst_port_u);

	// check for the vaccant_port and occupy it. the size of vaccant_ports array is 50
	for (u32 i = 0; i < 50; i++) {
		const u32 index            = i;
		struct vaccant_port *value = bpf_map_lookup_elem(&vaccant_ports, &index);
		if (value && value->occupied == 0) {
			bpf_spin_lock(&value->lock);
			value->occupied  = 1;
			NEW_PORT         = (__u32)bpf_ntohs(value->port);
			value->dest_port = dst_port;
			value->dest_ip   = dst_ip;
			bpf_spin_unlock(&value->lock);
			break;
		}

		// if (value && value->occupied == 0) {
		// occupy the proxy running at the vaccant port and store the destination ip and port
		// bpf_spin_lock(&value->lock);
		// value->occupied = 1;
		// NEW_PORT        = (__u32)bpf_ntohs(value->port);
		// value->dest_port = dst_port;
		// bpf_spin_unlock(&value->lock);

		// 	break;
		// }
	}

	u32 client_ip = 1;

	struct dest_info dest = {
		.dest_ip   = dst_ip,
		.dest_port = dst_port,
	};

	struct dest_info *pdest = bpf_map_lookup_elem(&port_mapping, &client_ip);
	bpf_printk("key address in port_access map:%p\n", &client_ip);
	if (pdest) {
		// Entry exists, update it
		bpf_printk("Entry exists in the port_access map, hence getting the [dest_ip:%lu] and [dest_port:%lu]\n", pdest->dest_ip, pdest->dest_port);
		*pdest = dest;
	} else {
		// Entry does not exist, insert it
		bpf_printk("Entry doesn't exist in the port_access map, hence setting the [dest_ip:%lu]and [dest_port:%lu]\n", dest.dest_ip, dest.dest_port);
		bpf_map_update_elem(&port_mapping, &client_ip, &dest, BPF_ANY);
	}

	// bpf_map_pop_elem(&vaccant_ports, value);
	// 	u32 *value2 = bpf_map_lookup_elem(&vaccant_ports, &index);
	// 	bpf_printk("vaccant proxy at port:%u\n", *value2);
	// }
	// redirecting to proxy.
	ctx->user_ip4  = NEW_IP;
	ctx->user_port = NEW_PORT;
	bpf_printk("destination IP: %u | destination Port: %u", ctx->user_ip4, ctx->user_port);
	return 1;
}

SEC("cgroup/getpeername4")
int k_getpeername4(struct bpf_sock_addr *ctx) {
	u64 pid = bpf_get_current_pid_tgid() >> 32;
	bpf_printk("getpeername4 called [PID:%llu]\n", pid);
	return 1;
}